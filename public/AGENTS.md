# AGENTS.md - AI Coding Assistant Guidelines

## 🚨 CRITICAL: useEffect Guidelines

### NEVER use useEffect for:
- Data fetching (use useQuery, useSWR, or Effect)
- Computed values (use useMemo)
- Event handlers (use proper event callbacks)
- Initializing global state (initialize outside component)
- Subscriptions without cleanup (memory leaks!)

### ONLY use useEffect when:
1. You need to synchronize with an external system
2. AND you've exhausted ALL other options
3. AND you've written proper cleanup
4. AND you've triple-checked dependencies
5. AND you've considered Effect-TS instead

## 🎯 Better Alternatives

### For Data Fetching:
```typescript
// ❌ NEVER DO THIS
useEffect(() => {
  fetch('/api/data').then(setData);
}, []);

// ✅ DO THIS INSTEAD
const { data } = useQuery(['key'], fetchData);
// OR with Effect-TS
const data = await Effect.runPromise(fetchDataEffect);
```

### For Derived State:
```typescript
// ❌ NEVER DO THIS
useEffect(() => {
  setFullName(firstName + ' ' + lastName);
}, [firstName, lastName]);

// ✅ DO THIS INSTEAD
const fullName = useMemo(() => firstName + ' ' + lastName, [firstName, lastName]);
```

### For Event Subscriptions:
```typescript
// ❌ PROBLEMATIC
useEffect(() => {
  const handler = () => console.log('clicked');
  window.addEventListener('click', handler);
  return () => window.removeEventListener('click', handler);
}, []);

// ✅ BETTER WITH EFFECT-TS
const clickEffect = Effect.async((resume) => {
  const handler = () => resume(Effect.succeed('clicked'));
  window.addEventListener('click', handler);
  return Effect.sync(() => window.removeEventListener('click', handler));
});
```

## 🚀 Introduction to Effect-TS

Effect-TS is a powerful library for managing side effects, async operations, and error handling in a type-safe, composable way.

### Key Concepts:
1. **Effect** - Represents a computation that may fail or succeed
2. **Pipe** - Compose operations in a readable way
3. **Error Handling** - Built-in, type-safe error management
4. **Resource Management** - Automatic cleanup and disposal

### Basic Example:
```typescript
import { Effect, pipe } from 'effect';

// Define an effect
const fetchUser = (id: string) =>
  Effect.tryPromise({
    try: () => fetch(`/api/users/${id}`).then(r => r.json()),
    catch: (error) => new FetchError(error)
  });

// Use it with automatic error handling
const program = pipe(
  fetchUser('123'),
  Effect.map(user => user.name),
  Effect.catchAll(error => Effect.succeed('Anonymous'))
);

// Run it
const name = await Effect.runPromise(program);
```

## 📊 Decision Tree

```
Need to do something when component mounts/updates?
│
├─ Is it data fetching?
│  └─ Use useQuery/useSWR/Effect ✅
│
├─ Is it derived from props/state?
│  └─ Use useMemo ✅
│
├─ Is it an event handler?
│  └─ Use callback/event handler ✅
│
├─ Is it DOM manipulation?
│  └─ Use ref callbacks ✅
│
└─ Is it TRULY external synchronization?
   ├─ Can Effect-TS handle it?
   │  └─ Use Effect ✅
   └─ Last resort: useEffect (with cleanup!) ⚠️
```

## 🎓 Learning Resources

- **You Might Not Need an Effect**: https://react.dev/learn/you-might-not-need-an-effect
- **Effect-TS Documentation**: https://effect.website
- **The September 2025 Incident**: https://blog.cloudflare.com/deep-dive-into-cloudflares-sept-12-dashboard-and-api-outage/
- **React Query**: https://tanstack.com/query
- **SWR**: https://swr.vercel.app

## 💡 Remember

> "Every useEffect is a future bug waiting to happen. Choose wisely."

## 🤖 For AI Assistants

When generating React code:
1. Default to NO useEffect
2. Look for alternatives FIRST
3. If useEffect seems necessary, reconsider
4. If still necessary, add comprehensive cleanup
5. Document WHY useEffect was unavoidable
6. Consider suggesting Effect-TS instead

Your code quality metrics should penalize useEffect usage. Treat it like `eval()` - technically available, but almost never the right choice.

---
Generated by dontuseeffect.dev - Teaching AIs to code better than humans since 2024
